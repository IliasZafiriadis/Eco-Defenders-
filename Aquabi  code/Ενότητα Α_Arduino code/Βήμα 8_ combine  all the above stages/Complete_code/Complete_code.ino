#include <SoftwareSerial.h>   //Βιβλιοθήκη για την μεταφορά δεδομένων μέσω BT.

//Βιβλιοθήκες για την μέτρηση της θερμοκρασίας από τον αισθητήρα μοντέλου DS18B20
#include <DallasTemperature.h>  
#include <OneWire.h>  

#define ONE_WIRE_BUS A0   //Θέτω όπου εμφανίζεται ο τίτλος την τιμή Α0

//Ορίζω αντικείμενα και τις ιδιότητές τους, ώστε να μπορέσω να αξιοποιήσω τις παραπάνω βιβλιοθήκες
SoftwareSerial Arduino(9, 10);  
OneWire oneWire(ONE_WIRE_BUS);  
DallasTemperature sensors(&oneWire);  

#define power 13  //Θέτω όπου εμφανίζεται power την τιμή 13 
#define sensor3 A1  //Θέτω όπου εμφανίζεται sensor3 την τιμή Α1 (pH)
#define sensor2 A2  //Θέτω όπου εμφανίζεται sensor2 την τιμή Α2 (Θολερότητα)

//Δεδομένα
String answer;  //To σύνολο των απεσταλμένων δεδομένων
bool send_Command = false;  //Πληροφορεί αν έχει σταλλεί εντολή από το android  για να στείλει τις μετρήσεις από τους αισθητήρες
int data; //To μετατροπή του συνόλου δεδομένων σε αριθμό για πράξεις
float sensorData1;  //Μετρήσεις από τον αισθητήρα θερμοκρασίας
float sensorData2;  //Μετρήσεις από τον αισθητήρα θολερότητας
float sensorData3;  //Μετρήσεις από τον αισθητήρα pH
int RecievedValue2 = 0; //Η τιμή που αντιστοιχεί στο joystick_x 
int RecievedValue3 = 0; //Η τιμή που αντιστοιχεί στο joytick_y
//Μεταβλητές για την εύρεση του pH 
unsigned long int avgValue; 
int buf[10], temp;  

//Κινητήρες
int enA = 6;  //Έξοδος για την ταχύτητα του αριστερού κινητήρα
//Μεταβλητές που καθορίζουν την φορά του αριστερού κινητήρα
int in1 = 7;  
int in2 = 5;  
//motorB connections  
int enB = 3;  //Έξοδος για την ταχύτητα του δεξιού κινητήρα
//Μεταβλητές που καθορίζουν την φορά του αριστερού κινητήρα
int in3 = 2; 
int in4 = 4;  
int Speed;  //Μέγιστη ταχύτητα η οποία θα μοιραστεί στους δύο κινητήρες

void setup() {  //============Βασική διαδικασία εκκίνησης============
  Serial.begin(9600); //Εκκίνηση επικοινωνίας μεσώ του bluetooth, των αισθητήρων και του monitor
  Arduino.begin(9600);  
  sensors.begin();  
  //Ορίζω αυτά τα pin ως εξόδους
  pinMode(power, OUTPUT);
  pinMode(enA, OUTPUT); 
  pinMode(enB, OUTPUT); 
  pinMode(in1, OUTPUT); 
  pinMode(in2, OUTPUT); 
  pinMode(in3, OUTPUT); 
  pinMode(in4, OUTPUT); 
  digitalWrite(power, LOW); //Μηδενίζω  , αρχικά, την τάση που λαμβάνουν οι αισθητήρες
} 
void loop() { //============Βασική διαδικασία βρόγχου============
  get_SpeedDataAndCommands_Phone ();  //Διαδικασία η οποία λαμβάνει και αναγωνρίζει τα δεδομένα για τους κινητήρες και τις εντολές
  if (send_Command) { //Αν έχει ληφθεί εντολή αποστολής δεδομένων, 
    digitalWrite(power, HIGH);  //Ανοίγω την τάση για τους αισθητήρες,
    delay(40);  //Περιμένω 40 χιλιοστά του δευτερολέπτου,
    get_sensorData_Raw_And_Send_Phone();  //Παίρνω  τις μετρήσεις από τους αισθητήρες θερμοκρασίας, θολερότητας και turbidity
    delay(10);  //Περιμένω  10 χιλιοστά του δευτερολέπτου
    digitalWrite(power, LOW);   } //Μηδενίζω  την τάση.
  
  send_ControllerData_SpeedControllers(); //Στέλνω τα δεδομένα για τους κινητήρες, στους κινητήρες
  delay(100);  }  //Περιμένω 1/10 του λεπτού
  
void get_SpeedDataAndCommands_Phone () {  //Διαδικασία για την απολαβή δεδομένων από τη συσκευή android
  while (Arduino.available()) { //Όσο ανιχνεύω εισερχόμενα δεδομένα,
    delay(10);  //Περιμένω 10 χιλιοστά του δευτερολέπτου
    if (Arduino.available() > 0) {  //Αν τα δεδομένα αντοιστιχούν σε κάποιο χαρακτήρα
      answer += char( Arduino.read());  //Προσθέτω τον χαρακτήρα στην μεταβλητή για να φτιάξω μία λέξη
      //Serial.print(answer); //Προβάλλω στο monitor την λέξη
    } 
  } 
  
  if (answer != "") { //Αν η λέξη που έφτιαξα έχει περιεχόμενο,
    data = answer.toInt();  //Μετατρέπω την λέξη αυτή σε αριθμό (εφόσον γνωρίζω πως αυτό που λαμβάνω θα είναι πάντα στη μορφή αριθμού)
    //Serial.println(data); //Προβάλλω στο monitor τον αριθμό
  
    if (data == 5) {  //Αν ο αριθμός ισούται με 5, σημαίνει πως ο χρήστης τεστάρει την επικοινωνία, οπότε
      Arduino.println("fine");  //Serial.println("Fine!");  //προβάλλω στο monitor την λέξη «Fine» και στέλνω στο arduino την λέξη «fine».
    } 
    delay(20);  //Περιμένω 20 χιλιοστά του δευτερολέπτου
    if (data == 1000) { //Αν ο αριθμός ισούται με 1000, σημαίνει πως πρέπει να στείλω τις μετρήσεις από τους αισθητήρες, οπότε
      send_Command = true; // το σηματοδοτώ ρυθμίζοντας την μεταβλητή send_Command 
      //Serial.print(send_Command); //Προβάλλω στο monitor τον αριθμό που αποτελεί την εντολή send_command, «1000».
      Serial.println("ok"); //Προβάλλω στο monitor τη λέξη «ok»
      Arduino.println("ok");  //Στέλνω στο arduino την λέξη «ok».
    } 
    else {  //Αλλιώς, σημαίνει πως δεν χρειάζεται να στείλω τις μετρήσεις από τους αισθητήρες, οπότε 
      send_Command = false; //το σηματοδοτώ ρυθμίζοντας την μεταβλητή send_Command 
      //Serial.println("nope"); //προβάλλω τη λέξη «nope»
      delay(10);  //και περιμένω 10 χιλιοστά του δευτερολέπτου.
    } 
  
     if (data >= 2000 && data <= 2255) {  //Αν ο αριθμός είναι μεταξύ του 2000 και του 2255, σημαίνει πως είναι η μεταβλητή που αντιστοιχεί στο joystick_x στη συσκευή android, όμως χρειάζεται πρώτα αποκωδικοποίηση, επομένως
      RecievedValue2 = data - 2000; //αφαιρώ 2000 από την τιμή,
      delay(20);  //και περιμένω 20 χιλιοστά του δευτερολέπτου.
    } 
  
    else if (data >= 3000 && data <= 3510) {  //Αλλιώς, αν η τιμή είναι μεταξύ του 3000 και του 3510, σημαίνει πως είναι η μεταβλητή που αντιστοιχεί στο joystick_y στη συσκευή android, όμως χρειάζεται πρώτα αποκωδικοποίηση, επομένως
      RecievedValue3 = data - 3255; //αφαιρώ το 3255 (ώστε να θέσω μηδενική τιμή, το //μέσο αυτού του πεδίου)
      delay(20);  //και περιμένω 20 χιλιοστά του δευτερολέπτου.
    } 
    answer = "";  //Σβήνω την απάντηση
  } 
} 
  
void get_sensorData_Raw_And_Send_Phone() {  //============Διαδικασία για την απολαβή των μετρήσεων και την αποστολή τους στη συσκευή android============
  /*Παίρνω 5 συνεχόμενες μετρήσεις (με 10 χιλιοστά του δευτερολέπτου διαφορά) από τον αισθητήρα θερμοκρασίας,
  τις αθροίζω, στην μεταβλητή sensorData1 και βγάζω τον μέσο όρο. 
  Όσο ο μέσος όρος δεν είναι αριθμός (δηλαδή έγινε σφάλμα), 
  επαναλαμβάνω αυτή τη διαδικασία.*/
  do  { 
    sensorData1 = 0;  
    for (int i = 1; i <= 5; i++) {  
      sensors.requestTemperatures();  
      sensorData1 = sensorData1 + sensors.getTempCByIndex(0); 
      delay(10);  
    } 
    sensorData1 = sensorData1 / 5.0;  
  } while (isnan(sensorData1)); 
  
  
  sensorData1 = sensorData1 + 1000.0; //Πρόσθετω σε αυτήν γνωστό αριθμό, 1000, ώστε να αλλάξει το πεδίο ορισμού του αισθητήρα και το πρόγραμμα android να την ξεχωρίζει.
  Serial.print(" --> "); Serial.println (sensorData1 - 1000.0); //Πρόβαλλω την μέτρηση από τον αισθητήρα θερμοκρασίας στο monitor
  delay(30);  //Περιμένω 30 χιλιοστά  του δευτερολέπτου.
  Arduino.print (String(sensorData1 * 100.0, HEX)); //Πολλαπλασιάζω την μέτρηση με το 100 ώστε να κρατήσω 2 δεκαδικά ψηφία, την μετατρέπω σε λέξη και την κωδικοποιώ στο δεκαεξαδικό σύστημα.
  
  /*Παίρνω 5 συνεχόμενες μετρήσεις (με 10 χιλιοστά του δευτερολέπτου διαφορά) από τον αισθητήρα θολερότητας,
    τις αθροίζω, στην μεταβλητή sensorData2 και βγάζω τον μέσο όρο. 
    Όσο ο μέσος όρος δεν είναι αριθμός (δηλαδή έγινε σφάλμα), 
    επαναλαμβάνω αυτή τη διαδικασία.*/
  do  { 
    sensorData2 = 0;  
    for (int i = 1; i <= 10; i++) { 
      sensorData2 = sensorData2 + analogRead(sensor2);  
      delay(50);  } 
    sensorData2 = sensorData2 / 10.0; 
  } while (isnan(sensorData2)); 
  
  delay(500);   //Περιμένω μισό δευτερόλεπτο.
  sensorData2 = sensorData2 * (5.0 / 1024.0) + 2000.0; //Ορίζω ως μονάδα μέτρησης της θελερότητας το 1V (volt) και προσθέτω 2000, ώστε να αλλάξει το πεδίο ορισμού του αισθητήρα με στόχο, το πρόγραμμα android να την ξεχωρίζει.
  
  
  Serial.print(" !--> "); Serial.println (sensorData2-2000.0);  //Πρόβαλλω την μέτρηση από τον αισθητήρα θολερότητας στο monitor.
  Arduino.print (String(sensorData2 * 100.0, HEX)); //Πολλαπλασιάζω την μέτρηση με το 100 ώστε να κρατήσω 2 δεκαδικά ψηφία, την μετατρέπω σε λέξη και την κωδικοποιώ στο δεκαεξαδικό σύστημα.
  delay(500); //Περιμένω μισό δευτερόλεπτο.
   
  sensorData3 = find_pH(sensor3) + 3000.0; /*Εκτελώ τη διαδικασία find_pH για να πάρω μέτρηση από τον αισθητήρα pH
  και προσθέτω σε αυτήν γνωστό αριθμό, 1000, 
  ώστε να αλλάξει το πεδίο ορισμού του αισθητήρα και 
  το πρόγραμμα android να την ξεχωρίζει.*/
   
  Serial.print(" ->-> "); Serial.println (sensorData3 - 3000.0);  //Πρόβαλλω την μέτρηση από τον αισθητήρα pH στο monitor.
  Arduino.print (String(sensorData3 * 100.0, HEX)); 
  delay(400); //Περιμένω 4/10 του δευτερολέπτου.
} 
  
void send_ControllerData_SpeedControllers() {   //============Διαδικασία για τη κίνηση των κινητήρων============
  int motorA; //Τιμή ταχύτητας αριστερού κινητήρα.  
  int motorB; //Τιμή ταχύτητα δεξιού κινητήρα.
  boolean rotation; //Αν η κίνηση γίνεται προς τα πίσω(false) ή προς τα μπροστά(true).
  
  if (isnan(RecievedValue2)) {  //Αν η η τιμή δεν είναι αριθμός (δηλαδή, έχει γίνει κάποιο σφάλμα),
    RecievedValue2 = 0; //Την θέτω 0
  } 
  if (isnan(RecievedValue3)) {  //Αν η η τιμή δεν είναι αριθμός (δηλαδή, έχει γίνει κάποιο σφάλμα),
    RecievedValue3 = 0; //Την θέτω 0
  } 
  
  if (RecievedValue3 <= 0) {  //Αν το joystick_y είναι μη θετικός αριθμός,
    Speed = RecievedValue3 * (-1);  //θέτω την γενική ταχύτητα με τον αντίθετό του,
     //ρυθμίζω τους κινητήρες έτσι ώστε να κινούν το όχημα προς τα πίσω και
    digitalWrite(in1, HIGH); 
    digitalWrite(in2, LOW); 
    digitalWrite(in3, HIGH);  
    digitalWrite(in4, LOW); 
    rotation = false; //Ορίζω πως η κίνηση γίνεται προς τα πίσω.
  } 
  if (RecievedValue3 > 0) { //Αν το joystick_y είναι θετικός αριθμός,
    Speed = RecievedValue3; //θέτω την γενική ταχύτητα ίση με αυτόν,
    //ρυθμίζω τους κινητήρες έτσι ώστε να κινούν το όχημα προς τα μπροστά και
    digitalWrite(in1, LOW); 
    digitalWrite(in2, HIGH);  
    digitalWrite(in3, LOW); 
    digitalWrite(in4, HIGH);  
    rotation = true;  //ορίζω πως η κίνηση γίνεται προς τα μπροστά.
  } 
  
  if (RecievedValue2 >= 128) {  //Αν το joystick_x είναι ίσο ή μεγαλύτερο του μισού του περίου ορισμού του (128), τότε
    motorA = map ( 128 * Speed , 0 , 128 * 255 /*32640*/, 0 , 255); //Θέτω την ταχύτητα του αριστερού κινητήρα με ποσοστό διανομής 100% της γενικής ταχύτητας και την το αντιστοιχώ σε πεδίο τιμών από 0 μέχρι 255. 
  } 
  else if (RecievedValue2 < 128) {  //Αλλιώς, αν το joystick_x είναι μικρότερο από το μισό του πεδίου ορισμού του (128), τότε
    motorA = map ( RecievedValue2 * Speed , 0 , 128 * 255 /*32640*/ , 0 , 255); //Θέτω την ταχύτητα του αριστερού κινητήρα με ποσοστό διανομής που ορίζει η ReceivedValue2 της γενικής ταχύτητας και την αντιστοιχώ σε πεδίο τιμών από 0 μέχρι 255. 
  } 
  if (255 - RecievedValue2 >= 128) {  //Αν το υπόλοιπο του joystick_x είναι ίσο ή μεγαλύτερο του μισού του περίου ορισμού του (128), τότε
    motorB = map ( 128 * Speed , 0 , 128 * 255 /*32640*/ , 0 , 255);  //Θέτω την ταχύτητα του αριστερού κινητήρα με ποσοστό διανομής 100% της γενικής ταχύτητας και την το αντιστοιχώ σε πεδίο τιμών από 0 μέχρι 255. 
  } 
  else if (255 - RecievedValue2 < 128) {  //Αλλιώς, αν το υπόλοιπο του joystick_x είναι μικρότερο από το μισό του πεδίου ορισμού του (128), τότε
    motorB = map ( (255 - RecievedValue2) * Speed , 0 , 128 * 255 /*32640*/ , 0 , 255); //Θέτω την ταχύτητα του αριστερού κινητήρα με το υπόλοιπο ποσοστό διανομής που ορίζει η ReceivedValue2 της γενικής ταχύτητας και την αντιστοιχώ σε πεδίο τιμών από 0 μέχρι 255. 
  } 
  analogWrite(enA, motorA); //Στέλνω την ταχύτητα του αριστερού κινητήρα στην έξοδο για τον αριστερό κινητήρα.
  analogWrite(enB, motorB); //Στέλνω την ταχύτητα του δεξιού κινητήρα στην έξοδο για τον δεξιό κινητήρα.
  Serial.print(motorA); Serial.print(" A ||  ");   Serial.print(motorB); Serial.print(" B | "); //Προβάλλω στο monitor, την ταχύτητα του κάθε κινητήρα και αν κινούνται προς τα μπροστά ή προς τα πίσω (κάτι που αρχικά πρέπει να ορίσω εγώ, όταν συνδέω τα καλώδια των κινητήρων στην πλακέτα).
  if (!rotation) {  
    Serial.println("Backwards");  
  } else if (rotation) {  
    Serial.println("Forward");  
  } 
} 
  
float find_pH (int sensor_pin) {// ============Διαδικασία για να βρεθεί μία ακριβή μέτρηση από τον αισθητήρα pH============
  /*Πηγή: https://circuitdigest.com/microcontroller-projects/arduino-ph-meter, με πρόσθετη, μία ενέργεια. */
  
  for (int i = 0; i < 10; i++)  
  { 
    buf[i] = analogRead(sensor_pin);  
    delay(10);  
  } 
  for (int i = 0; i < 9; i++) 
  { 
    for (int j = i + 1; j < 10; j++)  
    { 
      if (buf[i] > buf[j])  
      { 
        temp = buf[i];  
        buf[i] = buf[j];  
        buf[j] = temp;  
      } 
    } 
  } 
  avgValue = 0; 
  for (int i = 2; i < 8; i++) 
    avgValue += buf[i]; 
  float pHVol = (float)avgValue * 5.0 / 1024 / 6; 
  float phValue = -5.70 * pHVol + 21.34;  //Ρυθμίζω την τιμή βάσει των σφαλμάτων του αισθητήρα.
  delay(20);  
  return phValue; 
} 
